<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>CriticalSnake Postprocess</title>

  <link rel="stylesheet" href="3rd-party/nouislider14/nouislider.min.css">
  <link rel="stylesheet" href="3rd-party/leaflet16/leaflet.css">
  <style>
    body {
      font-size: 1rem;
    }
    #osm-map {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }

    /* TODO: We should define these styles from the JS code too */
    .noUi-horizontal .noUi-handle {
      width: 20px;
      height: 20px;
      right: -10px;
      top: -7px;
    }
    .noUi-handle:before {
      background: transparent;
      text-align: center;
      display: block;
      margin-top: -6px;
      margin-left: -9px;
    }
    .noUi-handle:after {
      background: transparent;
    }

    .noUi-horizontal .noUi-handle:before {
      content: "O";
    }
    .noUi-horizontal .noUi-handle-lower:before {
      content: "S";
    }
    .noUi-horizontal .noUi-handle-upper:before {
      content: "E";
    }
    .noUi-horizontal {
      height: 8px;
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <script src="3rd-party/leaflet16/leaflet.js"></script>
  <script src="3rd-party/leaflet-semicircle20/Semicircle.js"></script>
  <script src="3rd-party/jquery35/jquery-3.5.1.min.js"></script>
  <script src="3rd-party/geodesy11/latlon-spherical.min.js"></script>
  <script src="3rd-party/lzstring14/lz-string.min.js"></script>
  <script src="3rd-party/filesaver20/FileSaver.min.js"></script>
  <script src="3rd-party/nouislider14/nouislider.min.js"></script>
  <script src="3rd-party/lodash417/lodash.min.js"></script>
  <script src="3rd-party/vanilla-picker/vanilla-picker.min.js"></script>

  <script src="critical-snake/postprocess.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess-controls.js"></script>
  <script src="critical-snake/playback.js"></script>

  <script>
    function parseUrlParams(url) {
      const regex = /[?&]([^=#]+)=([^&#]*)/g;
      let params = {};
      let match;
      while(match = regex.exec(url)) {
        params[match[1]] = match[2];
      }
      return params;
    }

    const params = parseUrlParams(window.location.href);
    const bikeMap = createBikeMap(L);
    bikeMap.browseGroup.show();
    bikeMap.loadingGroup.hide();
    bikeMap.playbackGroup.hide();
    bikeMap.statsLabel.hide();

    bikeMap.postprocessGroup = new L.Control.PostprocessGroup({
      position: 'topright',
      filterNames: Object.keys(CriticalSnake.FilterBounds),
      snakeColors: CriticalSnake.PlaybackOptions.snakeColors,
    });

    let playbackFrameIdx = 0;
    let playbackDataset = null;
    bikeMap.playbackButton.click(() => {
      if (playbackDataset) {
        if (isRunning())
          pause();
        else
          resume();
      }
    });

    bikeMap.historySlider.attr({ min: 0, max: 500 });
    $(document).on("input", bikeMap.historySlider, () => {
      if (playbackDataset) {
        playbackFrameIdx = parseInt(bikeMap.historySlider.val());
        refreshView(playbackFrameIdx);
      }
    });

    let playbackFPS = 15;
    bikeMap.fpsInput.change(() => {
      playbackFPS = parseInt(bikeMap.fpsInput.val());
      console.log("FPS changed to", playbackFPS);
    });

    let rawDataset = {};
    let playbackRecording = null;
    bikeMap.browseButton.change(function() {
      // Validate selection and set visual indication for the loading progress.
      bikeMap.browseGroup.hide();
      bikeMap.loadingGroup.show();
      bikeMap.postprocessGroup.remove();

      if (this.files.length == 0)
        return;
      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      // Load and parse the actual file content.
      const reader = new FileReader();
      $(reader).on('load', (event) => {
        try {
          playbackRecording = this.files[0].name;
          const isCompressed = playbackRecording.endsWith(".recording");
          const snapshots = parseSnapshots(event.target.result, isCompressed);

          loadRawTracks(snapshots);
          bikeMap.statsLabel.show();
          bikeMap.playbackGroup.show();

          restoreOptions();
          bikeMap.postprocessGroup.addTo(bikeMap);
          bikeMap.postprocessGroup.reset(CriticalSnake);
          bikeMap.postprocessGroup.show();
        }
        catch (ex) {
          bikeMap.browseGroup.show();
          console.error("JSON parsing for file", this.files[0].name,
                        "failed with", ex);
        }
        bikeMap.loadingGroup.hide();
      });

      // Give the UI a chance to refresh and show the loading state.
      setTimeout(() => reader.readAsText(this.files[0]), 10);
    });

    bikeMap.postprocessGroup.timeRangeChanged = function(timeRange) {
      // Overwrite post-process parameters from control values in the global
      // `CriticalSnake.PostProcessOptions` instead of passing them to the
      // individual functions. It allows users to query and modify them easily
      // from the browser's debug console.
      CriticalSnake.mergePostProcessOptions({
        analyzeTracks: {
          startStamp: timeRange.start,
          endStamp: timeRange.end,
        },
        associateSnakes: {
          startTime: timeRange.origins,
        },
      });
    };

    bikeMap.postprocessGroup.locationFilterChanged = function(val) {
      if (!CriticalSnake.FilterBounds.hasOwnProperty(val)) {
        console.error("Invalid option: unknown filter-bounds", val);
        return;
      }

      console.log("Set data-point filter to", val);
      CriticalSnake.mergePostProcessOptions({
        analyzeTracks: { filterName: val },
      });

      const filterBounds = CriticalSnake.FilterBounds[val];
      bikeMap.panTo(filterBounds.getCenter());
    };

    bikeMap.postprocessGroup.storeOptionsClicked = function() {
      // Query existing options.
      const key = "CriticalSnake.PostProcessOptions";
      const val = localStorage.getItem(key);
      const opts = val ? JSON.parse(val) : {};

      // Add/overwrite options for the current recoring.
      opts[playbackRecording] = CriticalSnake.PostProcessOptions;
      localStorage.setItem(key, JSON.stringify(opts));

      console.log("Stored options for file", playbackRecording,
                  "in localStorage:", CriticalSnake.PostProcessOptions);
    };

    function restoreOptions() {
      const key = "CriticalSnake.PostProcessOptions";
      const val = localStorage.getItem(key);
      const opts = val ? JSON.parse(val) : {};

      if (opts.hasOwnProperty(playbackRecording)) {
        console.log("Restoring options for file", playbackRecording);
        CriticalSnake.mergePostProcessOptions(opts[playbackRecording]);
      } else {
        console.log("No options stored for file", playbackRecording);
      }
    }

    bikeMap.postprocessGroup.postprocessClicked = function() {
      bikeMap.postprocessGroup.hide();
      bikeMap.playbackGroup.hide();
      bikeMap.statsLabel.hide();
      bikeMap.loadingGroup.show();

      // Give the UI a chance to refresh and show the loading state.
      setTimeout(() => {
        try {
          postprocessRecording();
          bikeMap.statsLabel.show();
          bikeMap.playbackGroup.show();
        }
        catch (ex) {
          console.error("Postprocessing failed:", ex);
        }
        bikeMap.loadingGroup.hide();
        bikeMap.postprocessGroup.show();
      }, 10);
    };

    bikeMap.downloadButton.click(function() {
      bikeMap.playbackGroup.hide();
      bikeMap.loadingGroup.show();

      // Give the UI a chance to refresh and show the loading state.
      setTimeout(() => {
        const baseName = playbackRecording.endsWith(".json")
                       ? playbackRecording.slice(0, -5)
                       : playbackRecording;

        downloadReplay(baseName + ".replay", {
          begin: playbackDataset.begin,
          end: playbackDataset.end,
          dataPoints: playbackDataset.dataPoints,
          circles: playbackDataset.circles,
          segments: playbackDataset.segments,
        });

        bikeMap.loadingGroup.hide();
        bikeMap.playbackGroup.show();
      }, 10);
    });

    // ----------------------------------------------------

    function decompressDataset(compressedSnapshots) {
      const kilobyte = (str) => Math.round((str.length * 2) / 1024);

      const decompressionBegin = Date.now();
      const content = LZString.decompressFromUTF16(compressedSnapshots);
      console.log("Compressed size is:", kilobyte(compressedSnapshots), "KB");
      console.log("Decompressed size is:", kilobyte(content), "KB");
      console.log("Decompression took:", Date.now() - decompressionBegin, "ms");

      return content;
    }

    function parseSnapshots(content, isCompressed) {
      const decompressed = isCompressed ? decompressDataset(content) : content;
      const snapshots = JSON.parse(decompressed);

      // This is a temporary fix, because one version of the record page
      // incorrectly applied a JSON.stringify() where it wasn't necessary.
      if (typeof(snapshots) == "string") {
        console.warn("Parsed content is a string still and not a JSON.",
                    "Apparently, content was double-stringified.",
                    "Trying to parse again.", snapshots);
        return JSON.parse(snapshots);
      }

      return snapshots;
    }

    function loadRawTracks(snapshots) {
      const PostProcessor = new CriticalSnake.PostProcessor();

      const loadRawTracksBegin = Date.now();
      const [ dataPoints, tracks, timeRange ] = PostProcessor.loadRawTracks(snapshots);
      console.log("Data-points:", dataPoints);
      console.log("Tracks:", tracks);
      console.log("Loading raw tracks took:", Date.now() - loadRawTracksBegin, "ms");
      console.log("Data covers time range\nfrom:", timeRange.begin, "\nto:", timeRange.end);

      rawDataset.snapshots = snapshots;
      rawDataset.begin = timeRange.begin.getTime();
      rawDataset.end = timeRange.end.getTime();

      const duration = rawDataset.end - rawDataset.begin;
      bikeMap.postprocessGroup.percentToTimestamp = (percent) => {
        const offset = Math.round(duration * parseFloat(percent) / 100);
        return rawDataset.begin + offset;
      };
      bikeMap.postprocessGroup.timestampToPercent = (timestamp) => {
        const offset = (timestamp - rawDataset.begin);
        return (offset / duration) * 100;
      };

      // Allow to playback raw data for convenience
      console.assert(playbackDataset == null);
      playbackDataset = {
        dataPoints: dataPoints,
        tracks: tracks,
        begin: rawDataset.begin,
        end: rawDataset.end,
      };

      playbackFrameIdx = 0;
      refreshView(playbackFrameIdx);
    };

    const PostProcessor = new CriticalSnake.PostProcessor();
    function postprocessRecording() {
      const analyzeTracksBegin = Date.now();
      const [ tracks, dataPoints ] = PostProcessor.analyzeTracks(rawDataset.snapshots);
      console.log("Data-points:", dataPoints);
      console.log("Analyzing tracks took:", Date.now() - analyzeTracksBegin, "ms");

      const detectCirclesBegin = Date.now();
      const circles = PostProcessor.detectCircles(dataPoints);
      console.log("Circles:", circles);
      console.log("Populating circles took:", Date.now() - detectCirclesBegin, "ms");

      const startTime = 1598638200000; // 2020-08-28, 20:10
      const associateSnakesBegin = Date.now();
      const snakes = PostProcessor.associateSnakes(dataPoints, circles);
      console.log("Snakes detected by origin:", snakes);
      console.log("Associating snakes took:", Date.now() - associateSnakesBegin, "ms");

      const populateTrackSegmentsBegin = Date.now();
      const segments = PostProcessor.populateTrackSegments(dataPoints, tracks, circles);
      console.log("Segments:", segments);
      console.log("Populating track segments took:", Date.now() - populateTrackSegmentsBegin, "ms");

      const timeRange = PostProcessor.getTimeRange(circles);
      console.log("Data covers time range from/to:\n", timeRange.begin, "\n", timeRange.end);

      playbackDataset = {
        dataPoints: dataPoints,
        circles: circles,
        tracks: tracks,
        segments: segments,
        begin: timeRange.begin.getTime(),
        end: timeRange.end.getTime(),
      };

      playbackFrameIdx = 0;
      refreshView(playbackFrameIdx);
    }

    function downloadReplay(filename, json) {
      const kilobyte = (str) => Math.round((str.length * 2) / 1024);

      const text = JSON.stringify(json);
      console.log("Raw size is:", kilobyte(text), "KB");
      const compressed = LZString.compressToUTF16(text);
      console.log("Compressed size is:", kilobyte(compressed), "KB");

      const blob = new Blob([compressed], {type: "text/plain;charset=utf-16"});
      saveAs(blob, filename);
    }

    function refreshView(frameIdx) {
      const refreshViewBegin = Date.now();
      bikeMap.historySlider.val(frameIdx);

      const duration = playbackDataset.end - playbackDataset.begin;
      const offset = duration * (frameIdx / 500);
      const timestamp = playbackDataset.begin + offset;

      const bikeCount = playbackDataset.circles
                      ? drawTracks(playbackDataset, timestamp)
                      : drawRawTracks(playbackDataset, timestamp);

      // Adds a leading "0" for single digit values.
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      const d = new Date(timestamp);
      bikeMap.statsLabel.text(
        `📅 ${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ` +
        `🕗 ${pad2(d.getHours())}:${pad2(d.getMinutes())} ` +
        `📍🚲 ${bikeCount}`);

      const diff = Date.now() - refreshViewBegin;
      console.log("Rendering frame took:", Math.round(diff / 10) * 10, "ms");
    }

    // ----------------------------------------------------

    let rotatingCollisionCircles = 0;
    const drawFrameAction = () => {
      rotatingCollisionCircles += playbackFPS;
      switch (playbackFrameIdx) {
        case 0:
          refreshView(playbackFrameIdx);
          playbackFrameIdx += 1;
          break;
        case 500:
          refreshView(playbackFrameIdx);
          bikeMap.playbackButton.val("▶");
          playbackFrameIdx = 0;
          break;
        default:
          refreshView(playbackFrameIdx);
          playbackFrameIdx += 1;
          break;
      }
    };

    function resume() {
      console.log("Rendering", playbackFPS, "FPS (", 1000 / playbackFPS, "ms per frame)");
      bikeMap.playbackButton.val("||");

      const nextFrameAction = () => {
        drawFrameAction();
        if (isRunning())
          setTimeout(nextFrameAction, 1000 / playbackFPS);
      };

      setTimeout(nextFrameAction, 1000 / playbackFPS);
    }

    function pause() {
      bikeMap.playbackButton.val("▶");
    }

    function isRunning() {
      return bikeMap.playbackButton.val() != "▶";
    }

    // ----------------------------------------------------

    let trackHeads = L.layerGroup([], { pane: "markerPane" });
    let trackShadows = L.layerGroup([], { pane: "shadowPane" });

    function drawRawTracks(dataset, stamp, range, opacity) {
      range = range || 10;
      opacity = opacity || 0.1;

      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(trackShadows);
      trackShadows.clearLayers();

      const minute = 60 * 1000;
      const withinLast10Minutes = (idx) => {
        if (dataset.dataPoints[idx].first_stamp <= stamp)
          if (dataset.dataPoints[idx].last_stamp > stamp - range * minute)
            return true;
        return false;
      };

      let visibleBikes = 0;
      for (const track of dataset.tracks) {
        const dataPointIdxs = track.filter(withinLast10Minutes);
        const coords = dataPointIdxs.map(idx => dataset.dataPoints[idx]);
        if (coords.length > 1) {
          visibleBikes += 1;
          trackShadows.addLayer(
              L.polyline(coords, {
                color: "#888",
                opacity: opacity
              }));
        }
      }

      trackShadows.addTo(bikeMap);
      return visibleBikes;
    }

    function drawTracks(dataset, stamp) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(trackShadows);

      if (L.Browser.mobile) {
        // At this point we better avoid drawing track shadows on mobile,
        // because it's too resource intense for most devices.
      }
      else {
        trackShadows.clearLayers();
        drawShadows(trackShadows, dataset.dataPoints, dataset.segments, stamp);
        trackShadows.addTo(bikeMap);
      }

      trackHeads.clearLayers();
      const visibleBikes = drawCircles(trackHeads, dataset.dataPoints,
                                       dataset.circles, stamp);
      trackHeads.addTo(bikeMap);

      return visibleBikes;
    }

    function colors(snakeIdx) {
      const colors = CriticalSnake.PlaybackOptions.snakeColors;

      if (snakeIdx >= 0 && snakeIdx < colors.length)
        return colors[snakeIdx];

      return CriticalSnake.PlaybackOptions.defaultColor;
    }

    function drawShadows(canvas, dataPoints, segments, stamp) {
      const startedAlready = (seg) => seg.first_stamp <= stamp;
      const didNotStartYet = (idx) => !startedAlready(dataPoints[idx]);

      const findEndIndex = (seg) => {
        if (seg.last_stamp <= stamp)
          return -1;
        return seg.dataPointIdxs.findIndex(idx => didNotStartYet(idx));
      };

      for (const segment of segments.filter(startedAlready)) {
        // Draw non-associated track segments?
        //if (segment.snakeIdxs.length == 0)
        //  continue;

        // Draw segment entirely or only the first number of data-points.
        const end = findEndIndex(segment);
        const coordIdxs = end < 0 ? segment.dataPointIdxs
                                  : segment.dataPointIdxs.slice(0, end);

        for (const snakeIdx of segment.snakeIdxs) {
          canvas.addLayer(
              L.polyline(coordIdxs.map(idx => dataPoints[idx]), {
                color: colors(snakeIdx),
                opacity: 0.05
              }));
        }
      }
    }

    function drawCircles(canvas, dataPoints, circles, stamp) {
      const fullCircle = (c, idx) => L.circle(c, {
        color: colors(idx),
        fillOpacity: 0.75,
        radius: 10 * Math.log2(c.dataPointIdxs.length),
        stroke: false,
      });

      const semiCircle = (c, idx, from, to) => L.semiCircle(c, {
        color: colors(idx),
        fillOpacity: 0.75,
        radius: 10 * Math.log2(c.dataPointIdxs.length),
        startAngle: from,
        stopAngle: to,
        stroke: false,
      });

      const inTime = (c) => c.first_stamp <= stamp && c.last_stamp >= stamp;

      const trackIdxs = new Set();
      for (const circle of circles.filter(c => inTime(c))) {
        circle.dataPointIdxs.forEach(idx => trackIdxs.add(dataPoints[idx].trackIdx));
        switch (circle.snakeIdxs.length) {
          case 0:
            canvas.addLayer(fullCircle(circle, null));
            break;
          case 1:
            canvas.addLayer(fullCircle(circle, circle.snakeIdxs[0]));
            break;
          default:
            let angle = rotatingCollisionCircles;
            const arcSize = 360 / circle.snakeIdxs.length;
            for (const idx of circle.snakeIdxs) {
              canvas.addLayer(semiCircle(circle, idx, angle, angle + arcSize));
              angle += arcSize;
            }
            break;
        }
      }

      return trackIdxs.size;
    }

    function drawFilterBounds(color, weight, opacity) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(trackShadows);
      trackShadows.clearLayers();

      const opts = {
        color: color || "#f88",
        weight: weight || 1,
        opacity: opacity || 0.5,
      };

      for (const region in CriticalSnake.FilterBounds) {
        const bounds = CriticalSnake.FilterBounds[region];
        console.log("Filter bounds for", region, ":", bounds);
        trackShadows.addLayer(L.rectangle(bounds, opts));
      }

      trackShadows.addTo(bikeMap);
    }
  </script>
</body>
</html>
