<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>CriticalSnake Postprocess</title>

  <link rel="stylesheet" href="3rd-party/nouislider14/nouislider.min.css">
  <link rel="stylesheet" href="3rd-party/leaflet16/leaflet.css">
  <style>
    body {
      font-size: 1rem;
    }
    #osm-map {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }

    /* TODO: We should define these styles from the JS code too */
    .noUi-horizontal .noUi-handle {
      width: 20px;
      height: 20px;
      right: -10px;
      top: -7px;
    }
    .noUi-handle:before {
      background: transparent;
      text-align: center;
      display: block;
      margin-top: -6px;
      margin-left: -9px;
    }
    .noUi-handle:after {
      background: transparent;
    }

    .noUi-horizontal .noUi-handle:before {
      content: "O";
    }
    .noUi-horizontal .noUi-handle-lower:before {
      content: "S";
    }
    .noUi-horizontal .noUi-handle-upper:before {
      content: "E";
    }
    .noUi-horizontal {
      height: 8px;
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <script src="3rd-party/leaflet16/leaflet.js"></script>
  <script src="3rd-party/leaflet-semicircle20/Semicircle.js"></script>
  <script src="3rd-party/jquery35/jquery-3.5.1.min.js"></script>
  <script src="3rd-party/geodesy11/latlon-spherical.min.js"></script>
  <script src="3rd-party/lzstring14/lz-string.min.js"></script>
  <script src="3rd-party/filesaver20/FileSaver.min.js"></script>
  <script src="3rd-party/nouislider14/nouislider.min.js"></script>
  <script src="3rd-party/lodash417/lodash.min.js"></script>
  <script src="3rd-party/vanilla-picker/vanilla-picker.min.js"></script>

  <script src="critical-snake/postprocess.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess-controls.js"></script>
  <script src="critical-snake/playback.js"></script>
  <script src="critical-snake/playback-controls.js"></script>

  <script>
    function parseUrlParams(url) {
      const regex = /[?&]([^=#]+)=([^&#]*)/g;
      let params = {};
      let match;
      while(match = regex.exec(url)) {
        params[match[1]] = match[2];
      }
      return params;
    }

    const params = parseUrlParams(window.location.href);
    const bikeMap = createBikeMap(L);
    bikeMap.browseGroup.show();
    bikeMap.loadingGroup.hide();
    bikeMap.statsLabel.hide();

    bikeMap.playbackGroup = new L.Control.PlaybackGroup({
      position: 'bottomleft',
      fps: CriticalSnake.PlaybackOptions.fps,
      status: CriticalSnake.PlaybackStatus,
    });

    bikeMap.postprocessGroup = new L.Control.PostprocessGroup({
      position: 'topright',
      filterNames: Object.keys(CriticalSnake.FilterBounds),
      snakeColors: CriticalSnake.PlaybackOptions.snakeColors,
    });

    let playbackDataset = null;
    let rawDataset = {};
    let playbackRecording = null;
    let playbackRecordingHash = null;
    bikeMap.browseButton.change(function() {
      // Validate selection and set visual indication for the loading progress.
      bikeMap.browseGroup.hide();
      bikeMap.loadingGroup.show();
      bikeMap.playbackGroup.remove();
      bikeMap.postprocessGroup.remove();

      if (this.files.length == 0)
        return;
      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      // Load and parse the actual file content.
      const reader = new FileReader();
      $(reader).on('load', (event) => {
        try {
          playbackRecording = this.files[0].name;
          const isCompressed = playbackRecording.endsWith(".recording");
          const snapshots = parseSnapshots(event.target.result, isCompressed);

          loadRawTracks(snapshots);
          bikeMap.statsLabel.show();

          restoreOptions();
          resetOptionsForPostprocessGroup(bikeMap.postprocessGroup.options);
          bikeMap.postprocessGroup.addTo(bikeMap);
          bikeMap.postprocessGroup.show();

          bikeMap.playbackGroup.addTo(bikeMap);
          bikeMap.playbackGroup.setTimeRange(playbackDataset.begin, playbackDataset.end);
          bikeMap.playbackGroup.show();
        }
        catch (ex) {
          bikeMap.browseGroup.show();
          console.error("JSON parsing for file", this.files[0].name,
                        "failed with", ex);
        }
        bikeMap.loadingGroup.hide();
      });

      // Give the UI a chance to refresh and show the loading state.
      setTimeout(() => reader.readAsText(this.files[0]), 10);
    });

    bikeMap.postprocessGroup.timeRangeChanged = function(timeRange) {
      // Overwrite post-process parameters from control values in the global
      // `CriticalSnake.PostProcessOptions` instead of passing them to the
      // individual functions. It allows users to query and modify them easily
      // from the browser's debug console.
      CriticalSnake.mergePostProcessOptions({
        analyzeTracks: {
          startStamp: timeRange.start,
          endStamp: timeRange.end,
        },
        associateSnakes: {
          startTime: timeRange.origins,
        },
      });
    };

    bikeMap.postprocessGroup.locationFilterChanged = function(val) {
      if (!CriticalSnake.FilterBounds.hasOwnProperty(val)) {
        console.error("Invalid option: unknown filter-bounds", val);
        return;
      }

      console.log("Set data-point filter to", val);
      CriticalSnake.mergePostProcessOptions({
        analyzeTracks: { filterName: val },
      });

      const filterBounds = CriticalSnake.FilterBounds[val];
      bikeMap.panTo(filterBounds.getCenter());

      // Restore and populate options for the location and rebuild post-process
      // controls.
      bikeMap.postprocessGroup.remove();
      restoreOptions(val);
      resetOptionsForPostprocessGroup(bikeMap.postprocessGroup.options);
      bikeMap.postprocessGroup.addTo(bikeMap);
    };

    bikeMap.postprocessGroup.snakeColorChanged = function(idx, color) {
      CriticalSnake.PlaybackOptions.snakeColors[idx] = color;
      refreshView();
    };

    bikeMap.postprocessGroup.storeOptionsClicked = function() {
      // Query existing options.
      const key = "CriticalSnake";
      const val = localStorage.getItem(key);
      const allOpts = val ? JSON.parse(val) : {};

      // Add/overwrite options in the two-level registry (the current
      // recording's hash-code and the name of the location-filter).
      const lev1 = playbackRecordingHash;
      const lev2 = CriticalSnake.PostProcessOptions.analyzeTracks.filterName;

      allOpts[lev1] = allOpts[lev1] || {};
      allOpts[lev1][lev2] = {
        postprocess: CriticalSnake.PostProcessOptions,
        playback: CriticalSnake.PlaybackOptions,
      };

      localStorage.setItem(key, JSON.stringify(allOpts));
      console.log("Stored options for", playbackRecording, `(${lev2}):`,
                  allOpts[lev1][lev2]);
    };

    function restoreOptions(location) {
      const key = "CriticalSnake";
      const val = localStorage.getItem(key);
      const allOpts = val ? JSON.parse(val) : {};

      const lev1 = playbackRecordingHash.toString();
      const lev2 = location || CriticalSnake.PostProcessOptions.analyzeTracks.filterName;

      if (allOpts.hasOwnProperty(lev1) && allOpts[lev1].hasOwnProperty(lev2)) {
        CriticalSnake.mergePostProcessOptions(allOpts[lev1][lev2].postprocess);
        CriticalSnake.mergePlaybackOptions(allOpts[lev1][lev2].playback);
        console.log("Restored options for", playbackRecording, `(${lev2}):`,
                    allOpts[lev1][lev2]);
      } else {
        console.log("No options stored for", playbackRecording, `(${lev2})`);
      }
    }

    function resetOptionsForPostprocessGroup(opts) {
      const postprocess = CriticalSnake.PostProcessOptions;
      const playback = CriticalSnake.PlaybackOptions;

      if (postprocess.analyzeTracks && postprocess.analyzeTracks.filterName) {
        opts.locationFilter = postprocess.analyzeTracks.filterName;
      }

      if (postprocess.analyzeTracks && postprocess.associateSnakes) {
        opts.timeRange = {
          startStamp: postprocess.analyzeTracks.startStamp,
          originsStamp: postprocess.associateSnakes.startTime,
          endStamp: postprocess.analyzeTracks.endStamp,
        };
      }

      if (playback.snakeColors) {
        opts.snakeColors = playback.snakeColors;
      }
    }

    bikeMap.postprocessGroup.postprocessClicked = function() {
      bikeMap.postprocessGroup.hide();
      bikeMap.statsLabel.hide();
      bikeMap.loadingGroup.show();
      bikeMap.playbackGroup.remove();

      // Give the UI a chance to refresh and show the loading state.
      setTimeout(() => {
        try {
          postprocessRecording();

          bikeMap.playbackGroup.setTimeRange(playbackDataset.begin, playbackDataset.end);
          bikeMap.playbackGroup.addTo(bikeMap);
          bikeMap.statsLabel.show();
        }
        catch (ex) {
          console.error("Postprocessing failed:", ex);
        }
        bikeMap.loadingGroup.hide();
        bikeMap.postprocessGroup.show();
      }, 10);
    };

//    bikeMap.downloadButton.click(function() {
//      bikeMap.playbackGroup.hide();
//      bikeMap.loadingGroup.show();
//
//      // Give the UI a chance to refresh and show the loading state.
//      setTimeout(() => {
//        const baseName = playbackRecording.endsWith(".json")
//                       ? playbackRecording.slice(0, -5)
//                       : playbackRecording;
//
//        downloadReplay(baseName + ".replay", {
//          begin: playbackDataset.begin,
//          end: playbackDataset.end,
//          dataPoints: playbackDataset.dataPoints,
//          circles: playbackDataset.circles,
//          segments: playbackDataset.segments,
//        });
//
//        bikeMap.loadingGroup.hide();
//        bikeMap.playbackGroup.show();
//      }, 10);
//    });

    // ----------------------------------------------------

    function decompressDataset(compressedSnapshots) {
      const kilobyte = (str) => Math.round((str.length * 2) / 1024);

      const decompressionBegin = Date.now();
      const content = LZString.decompressFromUTF16(compressedSnapshots);
      console.log("Compressed size is:", kilobyte(compressedSnapshots), "KB");
      console.log("Decompressed size is:", kilobyte(content), "KB");
      console.log("Decompression took:", Date.now() - decompressionBegin, "ms");

      return content;
    }

    function hashCode(content) {
      const it = (hash, val) => (((hash << 5) - hash) + val.charCodeAt(0)) | 0;
      return content.split('').reduce(it, 0);
    }

    function parseSnapshots(content, isCompressed) {
      const decompressed = isCompressed ? decompressDataset(content) : content;
      playbackRecordingHash = hashCode(decompressed);

      const snapshots = JSON.parse(decompressed);

      // This is a temporary fix, because one version of the record page
      // incorrectly applied a JSON.stringify() where it wasn't necessary.
      if (typeof(snapshots) == "string") {
        console.warn("Parsed content is a string still and not a JSON.",
                    "Apparently, content was double-stringified.",
                    "Trying to parse again.", snapshots);
        return JSON.parse(snapshots);
      }

      return snapshots;
    }

    function loadRawTracks(snapshots) {
      const PostProcessor = new CriticalSnake.PostProcessor();

      const loadRawTracksBegin = Date.now();
      const [ dataPoints, tracks, timeRange ] = PostProcessor.loadRawTracks(snapshots);
      console.log("Data-points:", dataPoints);
      console.log("Tracks:", tracks);
      console.log("Loading raw tracks took:", Date.now() - loadRawTracksBegin, "ms");
      console.log("Data covers time range\nfrom:", timeRange.begin, "\nto:", timeRange.end);

      rawDataset.snapshots = snapshots;
      rawDataset.begin = timeRange.begin.getTime();
      rawDataset.end = timeRange.end.getTime();

      const duration = rawDataset.end - rawDataset.begin;
      bikeMap.postprocessGroup.percentToTimestamp = (percent) => {
        const offset = Math.round(duration * parseFloat(percent) / 100);
        return rawDataset.begin + offset;
      };
      bikeMap.postprocessGroup.timestampToPercent = (timestamp) => {
        const offset = (timestamp - rawDataset.begin);
        return (offset / duration) * 100;
      };

      // Allow to playback raw data for convenience
      console.assert(playbackDataset == null);
      playbackDataset = {
        dataPoints: dataPoints,
        tracks: tracks,
        begin: rawDataset.begin,
        end: rawDataset.end,
      };

      refreshView(playbackDataset.begin);
    };

    const PostProcessor = new CriticalSnake.PostProcessor();
    function postprocessRecording() {
      const analyzeTracksBegin = Date.now();
      const [ tracks, dataPoints ] = PostProcessor.analyzeTracks(rawDataset.snapshots);
      console.log("Data-points:", dataPoints);
      console.log("Analyzing tracks took:", Date.now() - analyzeTracksBegin, "ms");

      const detectCirclesBegin = Date.now();
      const circles = PostProcessor.detectCircles(dataPoints);
      console.log("Circles:", circles);
      console.log("Populating circles took:", Date.now() - detectCirclesBegin, "ms");

      const associateSnakesBegin = Date.now();
      const snakes = PostProcessor.associateSnakes(dataPoints, circles);
      console.log("Snakes detected by origin:", snakes);
      console.log("Associating snakes took:", Date.now() - associateSnakesBegin, "ms");

      const populateTrackSegmentsBegin = Date.now();
      const segments = PostProcessor.populateTrackSegments(dataPoints, tracks, circles);
      console.log("Segments:", segments);
      console.log("Populating track segments took:", Date.now() - populateTrackSegmentsBegin, "ms");

      const timeRange = PostProcessor.getTimeRange(circles);
      console.log("Data covers time range from/to:\n", timeRange.begin, "\n", timeRange.end);

      playbackDataset = {
        dataPoints: dataPoints,
        circles: circles,
        tracks: tracks,
        segments: segments,
        begin: timeRange.begin.getTime(),
        end: timeRange.end.getTime(),
      };

      refreshView(playbackDataset.begin);
    }

    function downloadReplay(filename, json) {
      const kilobyte = (str) => Math.round((str.length * 2) / 1024);

      const text = JSON.stringify(json);
      console.log("Raw size is:", kilobyte(text), "KB");
      const compressed = LZString.compressToUTF16(text);
      console.log("Compressed size is:", kilobyte(compressed), "KB");

      const blob = new Blob([compressed], {type: "text/plain;charset=utf-16"});
      saveAs(blob, filename);
    }

    function refreshView(playbackTime) {
      playbackTime = playbackTime || CriticalSnake.PlaybackStatus.frameTime;

      const refreshViewBegin = Date.now();
      const bikeCount = playbackDataset.circles
                      ? drawTracks(playbackDataset, playbackTime)
                      : drawRawTracks(playbackDataset, playbackTime);

      // Adds a leading "0" for single digit values.
      const pad2 = (val) => (val < 10 ? "0" : "") + val;
      const d = new Date(playbackTime);
      bikeMap.statsLabel.text(
        `ðŸ“… ${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ` +
        `ðŸ•— ${pad2(d.getHours())}:${pad2(d.getMinutes())} ` +
        `ðŸ“ðŸš² ${bikeCount}`);

      const diff = Date.now() - refreshViewBegin;
      console.log("Rendering frame took:", Math.round(diff / 10) * 10, "ms");
    }

    // ----------------------------------------------------

    let playbackFPS = 1;
    let rotatingCollisionCircles = 0;
    bikeMap.playbackGroup.renderFrame = function(timestamp) {
      rotatingCollisionCircles += playbackFPS;
      refreshView(timestamp);
    }

    bikeMap.playbackGroup.playbackToggled = function(running) {
      if (running) {
        console.log(`Rendering ${playbackFPS}FPS (${1000 / playbackFPS}ms per frame)`);
        bikeMap.postprocessGroup.enablePostprocessing(false);
      }
      else {
        bikeMap.postprocessGroup.enablePostprocessing(true);
      }
    }

    bikeMap.playbackGroup.fpsChanged = function(fps) {
      playbackFPS = fps;
      console.log("FPS changed to", playbackFPS);
    };

    // ----------------------------------------------------

    let trackHeads = L.layerGroup([], { pane: "markerPane" });
    let trackShadows = L.layerGroup([], { pane: "shadowPane" });

    function drawRawTracks(dataset, stamp, range, opacity) {
      range = range || 10;
      opacity = opacity || 0.1;

      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(trackShadows);
      trackShadows.clearLayers();

      const minute = 60 * 1000;
      const withinLast10Minutes = (idx) => {
        if (dataset.dataPoints[idx].first_stamp <= stamp)
          if (dataset.dataPoints[idx].last_stamp > stamp - range * minute)
            return true;
        return false;
      };

      let visibleBikes = 0;
      for (const track of dataset.tracks) {
        const dataPointIdxs = track.filter(withinLast10Minutes);
        const coords = dataPointIdxs.map(idx => dataset.dataPoints[idx]);
        if (coords.length > 1) {
          visibleBikes += 1;
          trackShadows.addLayer(
              L.polyline(coords, {
                color: "#888",
                opacity: opacity
              }));
        }
      }

      trackShadows.addTo(bikeMap);
      return visibleBikes;
    }

    function drawTracks(dataset, stamp) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(trackShadows);

      if (L.Browser.mobile) {
        // At this point we better avoid drawing track shadows on mobile,
        // because it's too resource intense for most devices.
      }
      else {
        trackShadows.clearLayers();
        drawShadows(trackShadows, dataset.dataPoints, dataset.segments, stamp);
        trackShadows.addTo(bikeMap);
      }

      trackHeads.clearLayers();
      const visibleBikes = drawCircles(trackHeads, dataset.dataPoints,
                                       dataset.circles, stamp);
      trackHeads.addTo(bikeMap);

      return visibleBikes;
    }

    function colors(snakeIdx) {
      const colors = CriticalSnake.PlaybackOptions.snakeColors;

      if (snakeIdx >= 0 && snakeIdx < colors.length)
        return colors[snakeIdx];

      return CriticalSnake.PlaybackOptions.defaultColor;
    }

    function drawShadows(canvas, dataPoints, segments, stamp) {
      const startedAlready = (seg) => seg.first_stamp <= stamp;
      const didNotStartYet = (idx) => !startedAlready(dataPoints[idx]);

      const findEndIndex = (seg) => {
        if (seg.last_stamp <= stamp)
          return -1;
        return seg.dataPointIdxs.findIndex(idx => didNotStartYet(idx));
      };

      for (const segment of segments.filter(startedAlready)) {
        // Draw non-associated track segments?
        //if (segment.snakeIdxs.length == 0)
        //  continue;

        // Draw segment entirely or only the first number of data-points.
        const end = findEndIndex(segment);
        const coordIdxs = end < 0 ? segment.dataPointIdxs
                                  : segment.dataPointIdxs.slice(0, end);

        for (const snakeIdx of segment.snakeIdxs) {
          canvas.addLayer(
              L.polyline(coordIdxs.map(idx => dataPoints[idx]), {
                color: colors(snakeIdx),
                opacity: 0.05
              }));
        }
      }
    }

    function drawCircles(canvas, dataPoints, circles, stamp) {
      const fullCircle = (c, idx) => L.circle(c, {
        color: colors(idx),
        fillOpacity: 0.75,
        radius: 10 * Math.log2(c.dataPointIdxs.length),
        stroke: false,
      });

      const semiCircle = (c, idx, from, to) => L.semiCircle(c, {
        color: colors(idx),
        fillOpacity: 0.75,
        radius: 10 * Math.log2(c.dataPointIdxs.length),
        startAngle: from,
        stopAngle: to,
        stroke: false,
      });

      const inTime = (c) => c.first_stamp <= stamp && c.last_stamp >= stamp;

      const trackIdxs = new Set();
      for (const circle of circles.filter(c => inTime(c))) {
        circle.dataPointIdxs.forEach(idx => trackIdxs.add(dataPoints[idx].trackIdx));
        switch (circle.snakeIdxs.length) {
          case 0:
            canvas.addLayer(fullCircle(circle, null));
            break;
          case 1:
            canvas.addLayer(fullCircle(circle, circle.snakeIdxs[0]));
            break;
          default:
            let angle = rotatingCollisionCircles;
            const arcSize = 360 / circle.snakeIdxs.length;
            for (const idx of circle.snakeIdxs) {
              canvas.addLayer(semiCircle(circle, idx, angle, angle + arcSize));
              angle += arcSize;
            }
            break;
        }
      }

      return trackIdxs.size;
    }

    function drawFilterBounds(color, weight, opacity) {
      bikeMap.removeLayer(trackHeads);
      bikeMap.removeLayer(trackShadows);
      trackShadows.clearLayers();

      const opts = {
        color: color || "#f88",
        weight: weight || 1,
        opacity: opacity || 0.5,
      };

      for (const region in CriticalSnake.FilterBounds) {
        const bounds = CriticalSnake.FilterBounds[region];
        console.log("Filter bounds for", region, ":", bounds);
        trackShadows.addLayer(L.rectangle(bounds, opts));
      }

      trackShadows.addTo(bikeMap);
    }
  </script>
</body>
</html>
